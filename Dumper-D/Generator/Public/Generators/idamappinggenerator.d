module generators.idamappinggenerator;

import std.stdio;
import std.string;
import std.path;
import std.file;
import std.conv;
import std.format;

import generators.generator;
import generators.dumpspacegenerator; // For shared types
import settings;

class IDAMappingGenerator : GeneratorImplementation
{
    private:
    alias PredefinedMemberLookupMapType = string[string];

    public:
    static PredefinedMemberLookupMapType predefinedMembers;

    static string mainFolderName = "IDA";
    static string subfolderName = "";

    static string mainFolder;
    static string subfolder;

    static string getMainFolderName()
    {
        return mainFolderName;
    }

    static string getSubfolderName()
    {
        return subfolderName;
    }

    private:
    static void generateIDCScript()
    {
        writeln("Generating IDC script for IDA Pro...");
        
        string idcContent = format(`// IDC Script for %s v%s
// Generated by Dumper-7 (D Language Version)
// Usage: Load this script in IDA Pro to apply function names and signatures

#include <idc.idc>

static main()
{
    Message("Starting IDA mapping application for %s...\n");
    
    // Apply function names
    ApplyFunctionNames();
    
    // Apply structure definitions
    ApplyStructureDefinitions();
    
    // Apply class definitions
    ApplyClassDefinitions();
    
    Message("IDA mapping application completed!\n");
}

static ApplyFunctionNames()
{
    Message("Applying function names...\n");
    
    // Example function mappings (these would be generated from actual data)
    MakeName(0x12345678, "UObject::IsA");
    MakeName(0x12345679, "UObject::GetClass");
    MakeName(0x1234567A, "UClass::GetDefaultObject");
    MakeName(0x1234567B, "FName::ToString");
    
    // More function names would be applied here...
    Message("Applied function names.\n");
}

static ApplyStructureDefinitions()
{
    Message("Applying structure definitions...\n");
    
    // Example structure definitions
    auto struct_id;
    
    // FVector structure
    struct_id = AddStrucEx(-1, "FVector", 0);
    AddStrucMember(struct_id, "X", 0x0, FF_FLOAT, -1, 4);
    AddStrucMember(struct_id, "Y", 0x4, FF_FLOAT, -1, 4);
    AddStrucMember(struct_id, "Z", 0x8, FF_FLOAT, -1, 4);
    
    // FName structure
    struct_id = AddStrucEx(-1, "FName", 0);
    AddStrucMember(struct_id, "ComparisonIndex", 0x0, FF_DWORD, -1, 4);
    AddStrucMember(struct_id, "Number", 0x4, FF_DWORD, -1, 4);
    
    // More structures would be defined here...
    Message("Applied structure definitions.\n");
}

static ApplyClassDefinitions()
{
    Message("Applying class definitions...\n");
    
    // Example class definitions
    auto struct_id;
    
    // UObject class
    struct_id = AddStrucEx(-1, "UObject", 0);
    AddStrucMember(struct_id, "VTable", 0x0, FF_QWORD, -1, 8);
    AddStrucMember(struct_id, "ObjectFlags", 0x8, FF_DWORD, -1, 4);
    AddStrucMember(struct_id, "InternalIndex", 0xC, FF_DWORD, -1, 4);
    AddStrucMember(struct_id, "Class", 0x10, FF_QWORD, -1, 8);
    AddStrucMember(struct_id, "Name", 0x18, FF_QWORD, -1, 8);
    AddStrucMember(struct_id, "Outer", 0x20, FF_QWORD, -1, 8);
    
    // UStruct class (inherits from UObject)
    struct_id = AddStrucEx(-1, "UStruct", 0);
    AddStrucMember(struct_id, "UObject", 0x0, FF_STRUCT, GetStrucIdByName("UObject"), 0x28);
    AddStrucMember(struct_id, "Super", 0x40, FF_QWORD, -1, 8);
    AddStrucMember(struct_id, "Children", 0x48, FF_QWORD, -1, 8);
    AddStrucMember(struct_id, "PropertiesSize", 0x50, FF_DWORD, -1, 4);
    AddStrucMember(struct_id, "MinAlignment", 0x54, FF_DWORD, -1, 4);
    
    // More classes would be defined here...
    Message("Applied class definitions.\n");
}

// Helper function to create function prototypes
static CreateFunctionPrototype(addr, name, returnType, params)
{
    MakeName(addr, name);
    
    // Set function type if possible
    SetType(addr, format("%%s %s(%s);", returnType, params));
}
`,
            Settings.Generator.gameName.length > 0 ? Settings.Generator.gameName : "UnknownGame",
            Settings.Generator.gameVersion.length > 0 ? Settings.Generator.gameVersion : "Unknown",
            Settings.Generator.gameName.length > 0 ? Settings.Generator.gameName : "UnknownGame"
        );

        string filePath = buildPath(mainFolder, "ida_script.idc");
        std.file.write(filePath, idcContent);
    }

    static void generateIDAPythonScript()
    {
        writeln("Generating IDA Python script...");
        
        string pythonContent = format(`# IDA Python Script for %s v%s
# Generated by Dumper-7 (D Language Version)
# Usage: Run this script in IDA Pro to apply comprehensive mappings

import ida_kernwin
import ida_name
import ida_struct
import ida_typeinf
import ida_bytes

def main():
    print("Starting IDA mapping application for %s...")
    
    # Apply function names and signatures
    apply_function_mappings()
    
    # Apply structure definitions
    apply_structure_definitions()
    
    # Apply type information
    apply_type_information()
    
    print("IDA mapping application completed!")

def apply_function_mappings():
    """Apply function names and signatures"""
    print("Applying function mappings...")
    
    # Example function mappings
    functions = {
        0x12345678: ("UObject::IsA", "bool __fastcall(UObject *this, UClass *class_ptr)"),
        0x12345679: ("UObject::GetClass", "UClass * __fastcall(UObject *this)"),
        0x1234567A: ("UClass::GetDefaultObject", "UObject * __fastcall(UClass *this)"),
        0x1234567B: ("FName::ToString", "void __fastcall(FName *this, FString *out_string)"),
    }
    
    for addr, (name, signature) in functions.items():
        ida_name.set_name(addr, name, ida_name.SN_NOWARN)
        # Apply function signature
        tinfo = ida_typeinf.tinfo_t()
        if ida_typeinf.parse_decl(tinfo, None, signature, ida_typeinf.PT_FUNC):
            ida_typeinf.apply_tinfo(addr, tinfo, ida_typeinf.TINFO_DEFINITE)
    
    print(f"Applied {len(functions)} function mappings")

def apply_structure_definitions():
    """Apply structure and class definitions"""
    print("Applying structure definitions...")
    
    # FVector structure
    create_structure("FVector", [
        ("X", 0x0, "float"),
        ("Y", 0x4, "float"), 
        ("Z", 0x8, "float")
    ])
    
    # FName structure
    create_structure("FName", [
        ("ComparisonIndex", 0x0, "int32_t"),
        ("Number", 0x4, "uint32_t")
    ])
    
    # UObject class
    create_structure("UObject", [
        ("VTable", 0x0, "void **"),
        ("ObjectFlags", 0x8, "uint32_t"),
        ("InternalIndex", 0xC, "int32_t"),
        ("Class", 0x10, "UClass *"),
        ("Name", 0x18, "FName"),
        ("Outer", 0x20, "UObject *")
    ])
    
    # UStruct class
    create_structure("UStruct", [
        ("Base", 0x0, "UObject"),
        ("Super", 0x40, "UStruct *"),
        ("Children", 0x48, "UField *"),
        ("PropertiesSize", 0x50, "int32_t"),
        ("MinAlignment", 0x54, "int32_t")
    ])
    
    print("Applied structure definitions")

def create_structure(name, members):
    """Helper function to create a structure with members"""
    # Delete existing structure if it exists
    existing_id = ida_struct.get_struc_id(name)
    if existing_id != ida_struct.BADADDR:
        ida_struct.del_struc(ida_struct.get_struc(existing_id))
    
    # Create new structure
    struct_id = ida_struct.add_struc(ida_struct.BADADDR, name, 0)
    if struct_id == ida_struct.BADADDR:
        print(f"Failed to create structure: {name}")
        return
    
    struc = ida_struct.get_struc(struct_id)
    for member_name, offset, type_str in members:
        # Parse type and add member
        tinfo = ida_typeinf.tinfo_t()
        if ida_typeinf.parse_decl(tinfo, None, type_str, ida_typeinf.PT_TYP):
            ida_struct.add_struc_member(struc, member_name, offset, 
                                      ida_bytes.get_flags_by_size(tinfo.get_size()),
                                      None, tinfo.get_size())

def apply_type_information():
    """Apply additional type information"""
    print("Applying type information...")
    
    # Apply type information to global variables
    globals_info = {
        0x87654321: ("GNames", "FNamePool *"),
        0x12345678: ("GObjects", "FUObjectArray *"),
        0xABCDEF00: ("GWorld", "UWorld *")
    }
    
    for addr, (name, type_str) in globals_info.items():
        ida_name.set_name(addr, name, ida_name.SN_NOWARN)
        tinfo = ida_typeinf.tinfo_t()
        if ida_typeinf.parse_decl(tinfo, None, type_str, ida_typeinf.PT_VAR):
            ida_typeinf.apply_tinfo(addr, tinfo, ida_typeinf.TINFO_DEFINITE)
    
    print(f"Applied {len(globals_info)} global variable types")

if __name__ == "__main__":
    main()
`,
            Settings.Generator.gameName.length > 0 ? Settings.Generator.gameName : "UnknownGame",
            Settings.Generator.gameVersion.length > 0 ? Settings.Generator.gameVersion : "Unknown",
            Settings.Generator.gameName.length > 0 ? Settings.Generator.gameName : "UnknownGame"
        );

        string filePath = buildPath(mainFolder, "ida_script.py");
        std.file.write(filePath, pythonContent);
    }

    static void generateFunctionsList()
    {
        writeln("Generating functions list...");
        
        string functionsContent = format(`# Function List for %s v%s
# Generated by Dumper-7 (D Language Version)
# Format: Address Name Signature

# Core UObject functions
0x12345678 UObject::IsA bool __fastcall(UObject *this, UClass *class_ptr)
0x12345679 UObject::GetClass UClass * __fastcall(UObject *this)
0x1234567A UObject::GetName FName __fastcall(UObject *this)
0x1234567B UObject::GetOuter UObject * __fastcall(UObject *this)

# Core UClass functions
0x1234567C UClass::GetDefaultObject UObject * __fastcall(UClass *this)
0x1234567D UClass::IsChildOf bool __fastcall(UClass *this, UClass *parent)

# Core FName functions
0x1234567E FName::ToString void __fastcall(FName *this, FString *out_string)
0x1234567F FName::GetDisplayNameEntry FNameEntry * __fastcall(FName *this)

# Core engine functions
0x12345680 ProcessEvent void __fastcall(UObject *this, UFunction *function, void *params)
0x12345681 StaticFindObject UObject * __fastcall(UClass *class_ptr, UObject *outer, const wchar_t *name)
0x12345682 StaticLoadObject UObject * __fastcall(UClass *class_ptr, UObject *outer, const wchar_t *name)

# More functions would be listed here...
`,
            Settings.Generator.gameName.length > 0 ? Settings.Generator.gameName : "UnknownGame",
            Settings.Generator.gameVersion.length > 0 ? Settings.Generator.gameVersion : "Unknown"
        );

        string filePath = buildPath(mainFolder, "functions.txt");
        std.file.write(filePath, functionsContent);
    }

    static void generateReadmeFile()
    {
        string readmeContent = format(`# IDA Pro Mapping Files for %s v%s

Generated by Dumper-7 (D Language Version)

## Files Description:

- **ida_script.idc**: IDC script for IDA Pro (legacy format)
- **ida_script.py**: Python script for IDA Pro (recommended)
- **functions.txt**: Text list of function addresses and signatures

## Usage Instructions:

### Using the Python Script (Recommended):
1. Open your binary in IDA Pro
2. Go to File -> Script File...
3. Select ida_script.py
4. The script will automatically apply all mappings

### Using the IDC Script:
1. Open your binary in IDA Pro  
2. Go to File -> Script File...
3. Select ida_script.idc
4. The script will apply function names and structure definitions

### Manual Application:
- Use functions.txt to manually apply function names
- Copy and paste function signatures as needed

## What Gets Applied:

- **Function Names**: Core UE4/UE5 function names
- **Function Signatures**: Parameter and return types
- **Structure Definitions**: UObject, UStruct, UClass hierarchies
- **Type Information**: Global variables and important data structures

## Notes:

- Addresses are examples and need to be updated for your specific binary
- Some functions may need manual signature adjustments
- Always backup your IDA database before running scripts

Generated on: %s
`,
            Settings.Generator.gameName.length > 0 ? Settings.Generator.gameName : "UnknownGame",
            Settings.Generator.gameVersion.length > 0 ? Settings.Generator.gameVersion : "Unknown",
            Clock.currTime().toISOExtString()
        );

        string filePath = buildPath(mainFolder, "README.md");
        std.file.write(filePath, readmeContent);
    }

    public:
    static void generate()
    {
        writeln("Generating IDA Pro mapping files...");

        // Create output directory
        if (!exists(mainFolder))
            mkdirRecurse(mainFolder);

        // Generate IDA mapping files
        generateIDCScript();
        generateIDAPythonScript();
        generateFunctionsList();
        generateReadmeFile();

        writeln("IDA mapping generation completed!");
    }

    static void initPredefinedMembers()
    {
        // Initialize predefined members for IDA mapping generation
        predefinedMembers["UObject"] = "class";
        predefinedMembers["UStruct"] = "class";
        predefinedMembers["UClass"] = "class";
        predefinedMembers["UFunction"] = "class";
        predefinedMembers["ProcessEvent"] = "function";
        predefinedMembers["StaticFindObject"] = "function";
        predefinedMembers["StaticLoadObject"] = "function";
    }

    static void initPredefinedFunctions()
    {
        // Initialize predefined functions for IDA mapping generation
    }
}

// Need to import Clock for timestamps
import std.datetime : Clock;