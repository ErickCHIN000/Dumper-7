#include <vector>
#include <array>
#include <unordered_map>
#include <format>

#include "Generators/DGenerator.h"
#include "Wrappers/MemberWrappers.h"
#include "Managers/MemberManager.h"
#include "Managers/PackageManager.h"
#include "Wrappers/EnumWrapper.h"

#include "../Settings.h"

constexpr std::string GetDTypeFromSize(uint8 Size)
{
	switch (Size)
	{
	case 1:
		return "ubyte";
	case 2:
		return "ushort";
	case 4:
		return "uint";
	case 8:
		return "ulong";
	default:
		return "INVALID_TYPE_SIZE_FOR_BIT_PADDING";
	}
}

std::string DGenerator::CppTypeToD(const std::string& CppType)
{
	// Basic type mappings from C++ to D
	static const std::unordered_map<std::string, std::string> typeMap = {
		// Integer types
		{"int8", "byte"},
		{"uint8", "ubyte"},
		{"int16", "short"},
		{"uint16", "ushort"},
		{"int32", "int"},
		{"uint32", "uint"},
		{"int64", "long"},
		{"uint64", "ulong"},
		{"char", "char"},
		{"wchar_t", "wchar"},
		
		// Floating point
		{"float", "float"},
		{"double", "double"},
		
		// Boolean
		{"bool", "bool"},
		
		// Void
		{"void", "void"},
		
		// Common UE types
		{"FString", "FString"},
		{"FName", "FName"},
		{"FText", "FText"},
	};
	
	auto it = typeMap.find(CppType);
	if (it != typeMap.end()) {
		return it->second;
	}
	
	// Handle pointer types
	if (CppType.ends_with("*")) {
		std::string baseType = CppType.substr(0, CppType.length() - 1);
		// Trim whitespace
		while (!baseType.empty() && baseType.back() == ' ') {
			baseType.pop_back();
		}
		return CppTypeToD(baseType) + "*";
	}
	
	// Handle const types
	if (CppType.starts_with("const ")) {
		std::string baseType = CppType.substr(6);
		return "const(" + CppTypeToD(baseType) + ")";
	}
	
	// Handle reference types (convert to pointers in D)
	if (CppType.ends_with("&")) {
		std::string baseType = CppType.substr(0, CppType.length() - 1);
		// Trim whitespace
		while (!baseType.empty() && baseType.back() == ' ') {
			baseType.pop_back();
		}
		return CppTypeToD(baseType) + "*";
	}
	
	// Handle template types like TArray<T>
	if (CppType.find('<') != std::string::npos) {
		// For now, just return the type as-is, but could be improved
		return CppType;
	}
	
	// Default: return as-is (for UE classes and structs)
	return CppType;
}

std::string DGenerator::MakeMemberString(const std::string& Type, const std::string& Name, std::string&& Comment)
{
	// Convert C++ type to D type
	std::string DType = CppTypeToD(Type);
	
	//<tab><--45 chars--><-------50 chars----->
	//     Type          MemberName;           // Comment
	int NumSpacesToComment;

	if (DType.length() < 45)
	{
		NumSpacesToComment = 50;
	}
	else if ((DType.length() + Name.length()) > 95)
	{
		NumSpacesToComment = 1;
	}
	else
	{
		NumSpacesToComment = 50 - (DType.length() - 45);
	}

	return std::format("\t{:{}} {}; {:{}} // {}\n", DType, 45, Name, " ", NumSpacesToComment, std::move(Comment));
}

std::string DGenerator::MakeMemberStringWithoutName(const std::string& Type)
{
	std::string DType = CppTypeToD(Type);
	return '\t' + DType + ";\n";
}

std::string DGenerator::GenerateBytePadding(const int32 Offset, const int32 PadSize, std::string&& Reason)
{
	return MakeMemberString("ubyte", std::format("Pad_{:X}[0x{:X}]", Offset, PadSize), std::format("0x{:04X}(0x{:04X})({})", Offset, PadSize, std::move(Reason)));
}

std::string DGenerator::GenerateBitPadding(uint8 UnderlayingSizeBytes, const uint8 PrevBitPropertyEndBit, const int32 Offset, const int32 PadSize, std::string&& Reason)
{
	return MakeMemberString(GetDTypeFromSize(UnderlayingSizeBytes), std::format("BitPad_{:X}_{:X} : {:d}", Offset, PrevBitPropertyEndBit, PadSize), std::format("0x{:04X}(0x{:04X})({})", Offset, UnderlayingSizeBytes, std::move(Reason)));
}

void DGenerator::WriteFileHead(StreamType& File, PackageInfoHandle Package, EFileType Type, const std::string& CustomFileComment, const std::string& CustomIncludes)
{
	namespace DSettings = Settings::CppGenerator; // Reuse C++ settings for now

	// Write D module declaration
	if (Type == EFileType::SdkD)
		File << "module sdk;\n\n";
	else if (Package.IsValidHandle())
		File << std::format("module sdk.{};\n\n", Package.GetName()) << std::endl;
	else
		File << "module sdk.basic;\n\n";

	File << R"(/*
* SDK generated by Dumper-7 for D language
*
* https://github.com/Encryqed/Dumper-7
*/

)";

	if (Type == EFileType::SdkD)
		File << std::format("// {}\n// {}\n", Settings::Generator::GameName, Settings::Generator::GameVersion);
	

	File << std::format("// {}\n\n", Package.IsValidHandle() ? std::format("Package: {}", Package.GetName()) : CustomFileComment);

	if (!CustomIncludes.empty())
		File << CustomIncludes + "\n";
}

void DGenerator::WriteFileEnd(StreamType& File, EFileType Type)
{
	// D files don't need explicit end markers like C++
	File << "\n";
}

void DGenerator::Generate()
{
	// Generate SDK.d with sorted packages
	StreamType SdkD(MainFolder / "SDK.d");
	GenerateSDKHeader(SdkD);

	// Generate PropertyFixup.d
	StreamType PropertyFixup(MainFolder / "PropertyFixup.d");
	GeneratePropertyFixupFile(PropertyFixup);

	// Generate UnrealContainers.d
	StreamType UnrealContainers(MainFolder / "UnrealContainers.d");
	GenerateUnrealContainers(UnrealContainers);

	StreamType DebugAssertions;

	if constexpr (Settings::Debug::bGenerateAssertionFile)
	{
		DebugAssertions.open(MainFolder / "DebugAssertions.d");
		GenerateDebugAssertions(DebugAssertions);
	}

	// Generate Basic.d  
	StreamType BasicD(MainFolder / "Basic.d");
	GenerateBasicFiles(BasicD, DebugAssertions);

	// TODO: Generate packages like the C++ generator does
	// For now, create a basic structure
}

void DGenerator::GenerateSDKHeader(StreamType& SdkD)
{
	WriteFileHead(SdkD, nullptr, EFileType::SdkD, "Includes the entire SDK. Import files directly for faster compilation!");

	// Import all the generated modules
	SdkD << "public import sdk.basic;\n";
	SdkD << "public import sdk.unrealcontainers;\n";
	SdkD << "public import sdk.propertyfixup;\n";

	auto ForEachElementCallback = [&SdkD](const PackageManagerIterationParams& OldParams, const PackageManagerIterationParams& NewParams, bool bIsStruct) -> void
	{
		PackageInfoHandle CurrentPackage = PackageManager::GetInfo(NewParams.RequiredPackage);

		const bool bHasClassesFile = CurrentPackage.HasClasses();
		const bool bHasStructsFile = (CurrentPackage.HasStructs() || CurrentPackage.HasEnums());

		if (bIsStruct && bHasStructsFile)
			SdkD << std::format("public import sdk.{}_structs;\n", CurrentPackage.GetName());

		if (!bIsStruct && bHasClassesFile)
			SdkD << std::format("public import sdk.{}_classes;\n", CurrentPackage.GetName());
	};

	PackageManager::IterateDependencies(ForEachElementCallback);

	WriteFileEnd(SdkD, EFileType::SdkD);
}

void DGenerator::GenerateBasicFiles(StreamType& BasicD, StreamType& AssertionsFile)
{
	WriteFileHead(BasicD, nullptr, EFileType::BasicD, "Basic D types and definitions");

	// Basic D equivalents of C++ types and UE types
	BasicD << R"(
// Basic types used throughout the SDK
alias int8 = byte;
alias int16 = short;
alias int32 = int;
alias int64 = long;
alias uint8 = ubyte;
alias uint16 = ushort;
alias uint32 = uint;
alias uint64 = ulong;

// Basic Unreal Engine types
struct FString
{
    wchar* Data;     // Wide character data pointer
    int Count;       // Number of characters (excluding null terminator)
    int Max;         // Maximum capacity
    
    @property const(wchar)[] toString() const
    {
        return Data ? Data[0..Count] : null;
    }
}

struct FName  
{
    uint Index;      // Index into the names array
    uint Number;     // Instance number for duplicate names
    
    // TODO: Add methods to resolve name string
}

struct FText
{
    // TODO: Implement FText for D - complex structure with localization support
    void* Data;      // Placeholder for now
}

// Basic vector types
struct FVector
{
    float X = 0.0f;
    float Y = 0.0f;
    float Z = 0.0f;
    
    this(float x, float y, float z) @nogc nothrow
    {
        X = x; Y = y; Z = z;
    }
}

struct FVector2D
{
    float X = 0.0f;
    float Y = 0.0f;
    
    this(float x, float y) @nogc nothrow
    {
        X = x; Y = y;
    }
}

struct FRotator
{
    float Pitch = 0.0f;
    float Yaw = 0.0f;
    float Roll = 0.0f;
    
    this(float pitch, float yaw, float roll) @nogc nothrow
    {
        Pitch = pitch; Yaw = yaw; Roll = roll;
    }
}

// Basic color structure
struct FLinearColor
{
    float R = 0.0f;
    float G = 0.0f;
    float B = 0.0f;
    float A = 1.0f;
    
    this(float r, float g, float b, float a = 1.0f) @nogc nothrow
    {
        R = r; G = g; B = b; A = a;
    }
}

)";

	WriteFileEnd(BasicD, EFileType::BasicD);
}

void DGenerator::GenerateUnrealContainers(StreamType& UEContainersHeader)
{
	WriteFileHead(UEContainersHeader, nullptr, EFileType::UnrealContainers, "Unreal Engine container types for D");

	UEContainersHeader << R"(
import sdk.basic;

// TArray implementation for D
struct TArray(T)
{
    T* Data;         // Pointer to array data
    int Count;       // Number of elements
    int Max;         // Maximum capacity
    
    // Basic array operations
    @property bool empty() const @nogc nothrow
    {
        return Count == 0;
    }
    
    @property size_t length() const @nogc nothrow
    {
        return cast(size_t)Count;
    }
    
    T opIndex(size_t index) const @nogc nothrow
    {
        assert(index < Count);
        return Data[index];
    }
    
    ref T opIndex(size_t index) @nogc nothrow
    {
        assert(index < Count);
        return Data[index];
    }
    
    // Range interface for foreach
    @property T* ptr() @nogc nothrow { return Data; }
    @property const(T)* ptr() const @nogc nothrow { return Data; }
    
    // Slice operation
    T[] opSlice() @nogc nothrow
    {
        return Data ? Data[0..Count] : null;
    }
    
    T[] opSlice(size_t start, size_t end) @nogc nothrow
    {
        assert(start <= end && end <= Count);
        return Data ? Data[start..end] : null;
    }
}

// TSparseArray implementation for D
struct TSparseArray(T)
{
    TArray!T Data;
    // TODO: Add sparse array specific members
}

// TSet implementation for D  
struct TSet(T)
{
    // TODO: Implement TSet for D
    void* Data;      // Placeholder
}

// TMap implementation for D
struct TMap(K, V)
{
    // TODO: Implement TMap for D
    void* Data;      // Placeholder  
}

// Weak pointer types
struct TWeakObjectPtr(T)
{
    // TODO: Implement weak pointer for D
    void* Data;      // Placeholder
}

struct TSoftObjectPtr(T)
{
    // TODO: Implement soft pointer for D
    void* Data;      // Placeholder
}

)";

	WriteFileEnd(UEContainersHeader, EFileType::UnrealContainers);
}

void DGenerator::GeneratePropertyFixupFile(StreamType& PropertyFixup)
{
	WriteFileHead(PropertyFixup, nullptr, EFileType::PropertyFixup, "Property fixup definitions");

	PropertyFixup << R"(
// Property fixup code for D
// TODO: Implement property fixup logic

)";

	WriteFileEnd(PropertyFixup, EFileType::PropertyFixup);
}

void DGenerator::GenerateDebugAssertions(StreamType& AssertionStream)
{
	WriteFileHead(AssertionStream, nullptr, EFileType::DebugAssertions, "Debug assertions");

	AssertionStream << R"(
// Debug assertion code for D
// TODO: Implement debug assertions

)";

	WriteFileEnd(AssertionStream, EFileType::DebugAssertions);
}

// Stub implementations for required methods
std::string DGenerator::GenerateMembers(const StructWrapper& Struct, const MemberManager& Members, int32 SuperSize, int32 SuperLastMemberEnd, int32 SuperAlign, int32 PackageIndex)
{
	// TODO: Implement member generation for D
	return "";
}

DGenerator::FunctionInfo DGenerator::GenerateFunctionInfo(const FunctionWrapper& Func)
{
	// TODO: Implement function info generation for D
	return FunctionInfo{};
}

std::string DGenerator::GenerateSingleFunction(const FunctionWrapper& Func, const std::string& StructName, StreamType& FunctionFile, StreamType& ParamFile, StreamType& AssertionFile)
{
	// TODO: Implement single function generation for D
	return "";
}

std::string DGenerator::GenerateFunctions(const StructWrapper& Struct, const MemberManager& Members, const std::string& StructName, StreamType& FunctionFile, StreamType& ParamFile, StreamType& AssertionFile)
{
	// TODO: Implement functions generation for D
	return "";
}

void DGenerator::GenerateStruct(const StructWrapper& Struct, StreamType& StructFile, StreamType& FunctionFile, StreamType& ParamFile, StreamType& AssertionFile, int32 PackageIndex, const std::string& StructNameOverride)
{
	// TODO: Implement struct generation for D
}

void DGenerator::GenerateEnum(const EnumWrapper& Enum, StreamType& StructFile)
{
	if (!Enum.IsValid())
		return;

	CollisionInfoIterator EnumValueIterator = Enum.GetMembers();

	int32 NumValues = 0x0;
	std::string MemberString;

	for (const EnumCollisionInfo& Info : EnumValueIterator)
	{
		NumValues++;
		MemberString += std::format("\t{:{}} = {},\n", Info.GetUniqueName(), 40, Info.GetValue());
	}

	if (!MemberString.empty()) [[likely]]
		MemberString.pop_back();

	// D enum syntax (similar to C++ but without 'class' keyword)
	StructFile << std::format(R"(
// {}
// NumValues: 0x{:04X}
enum {} : {}
{{
{}
}}
)", Enum.GetFullName()
  , NumValues
  , GetEnumPrefixedName(Enum)
  , CppTypeToD(GetEnumUnderlayingType(Enum))  // Convert underlying type to D
  , MemberString);
}

std::string DGenerator::GetMemberTypeString(const PropertyWrapper& MemberWrapper, int32 PackageIndex, bool bAllowForConstPtrMembers)
{
	// TODO: Implement member type string generation for D
	return "";
}

std::string DGenerator::GetMemberTypeString(UEProperty Member, int32 PackageIndex, bool bAllowForConstPtrMembers)
{
	// TODO: Implement member type string generation for D
	return "";
}

std::string DGenerator::GetMemberTypeStringWithoutConst(UEProperty Member, int32 PackageIndex, bool* bOutIsUnknownProperty)
{
	// TODO: Implement member type string generation for D
	return "";
}

std::string DGenerator::GetFunctionSignature(UEFunction Func)
{
	// TODO: Implement function signature generation for D
	return "";
}

std::string DGenerator::GetStructPrefixedName(const StructWrapper& Struct)
{
	if (Struct.IsFunction())
		return Struct.GetUnrealStruct().GetOuter().GetValidName() + "_" + Struct.GetName();

	auto [ValidName, bIsUnique] = Struct.GetUniqueName();

	if (bIsUnique) [[likely]]
		return ValidName;

	/* Package_FStructName (using underscore instead of :: for D) */
	return PackageManager::GetName(Struct.GetUnrealStruct().GetPackageIndex()) + "_" + ValidName;
}

std::string DGenerator::GetEnumPrefixedName(const EnumWrapper& Enum)
{
	auto [ValidName, bIsUnique] = Enum.GetUniqueName();

	if (bIsUnique) [[likely]]
		return ValidName;

	/* Package_ESomeEnum (using underscore instead of :: for D) */
	return PackageManager::GetName(Enum.GetUnrealEnum().GetPackageIndex()) + "_" + ValidName;
}

std::string DGenerator::GetEnumUnderlayingType(const EnumWrapper& Enum)
{
	static constexpr std::array<const char*, 8> UnderlayingTypesBySize = {
		"ubyte",   // D equivalent of uint8
		"ushort",  // D equivalent of uint16
		"InvalidEnumSize",
		"uint",    // D equivalent of uint32
		"InvalidEnumSize",
		"InvalidEnumSize",
		"InvalidEnumSize",
		"ulong"    // D equivalent of uint64
	};

	return Enum.GetUnderlyingTypeSize() <= 0x8 ? UnderlayingTypesBySize[static_cast<size_t>(Enum.GetUnderlyingTypeSize()) - 1] : "ubyte";
}

std::string DGenerator::GetAssertionMacroString(const std::string& PrefixedStructUniqueName)
{
	// TODO: Implement assertion macro string for D
	return "";
}

std::string DGenerator::GetCycleFixupType(const StructWrapper& Struct, bool bIsForInheritance)
{
	// TODO: Implement cycle fixup type for D
	return "";
}

std::unordered_map<std::string, UEProperty> DGenerator::GetUnknownProperties()
{
	// TODO: Implement unknown properties for D
	return {};
}

void DGenerator::GenerateEnumFwdDeclarations(StreamType& ClassOrStructFile, PackageInfoHandle Package, bool bIsClassFile)
{
	// TODO: Implement enum forward declarations for D
}

void DGenerator::InitPredefinedMembers()
{
	// TODO: Initialize predefined members for D
}

void DGenerator::InitPredefinedFunctions()
{
	// TODO: Initialize predefined functions for D
}