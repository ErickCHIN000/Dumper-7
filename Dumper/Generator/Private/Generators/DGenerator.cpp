#include <vector>
#include <array>
#include <unordered_map>
#include <format>

#include "Generators/DGenerator.h"
#include "Wrappers/MemberWrappers.h"
#include "Managers/MemberManager.h"
#include "Managers/PackageManager.h"

#include "../Settings.h"

constexpr std::string GetDTypeFromSize(uint8 Size)
{
	switch (Size)
	{
	case 1:
		return "ubyte";
	case 2:
		return "ushort";
	case 4:
		return "uint";
	case 8:
		return "ulong";
	default:
		return "INVALID_TYPE_SIZE_FOR_BIT_PADDING";
	}
}

std::string DGenerator::CppTypeToD(const std::string& CppType)
{
	// Basic type mappings from C++ to D
	static const std::unordered_map<std::string, std::string> typeMap = {
		// Integer types
		{"int8", "byte"},
		{"uint8", "ubyte"},
		{"int16", "short"},
		{"uint16", "ushort"},
		{"int32", "int"},
		{"uint32", "uint"},
		{"int64", "long"},
		{"uint64", "ulong"},
		{"char", "char"},
		{"wchar_t", "wchar"},
		
		// Floating point
		{"float", "float"},
		{"double", "double"},
		
		// Boolean
		{"bool", "bool"},
		
		// Void
		{"void", "void"},
		
		// Common UE types
		{"FString", "FString"},
		{"FName", "FName"},
		{"FText", "FText"},
	};
	
	auto it = typeMap.find(CppType);
	if (it != typeMap.end()) {
		return it->second;
	}
	
	// Handle pointer types
	if (CppType.ends_with("*")) {
		std::string baseType = CppType.substr(0, CppType.length() - 1);
		// Trim whitespace
		while (!baseType.empty() && baseType.back() == ' ') {
			baseType.pop_back();
		}
		return CppTypeToD(baseType) + "*";
	}
	
	// Handle const types
	if (CppType.starts_with("const ")) {
		std::string baseType = CppType.substr(6);
		return "const(" + CppTypeToD(baseType) + ")";
	}
	
	// Handle reference types (convert to pointers in D)
	if (CppType.ends_with("&")) {
		std::string baseType = CppType.substr(0, CppType.length() - 1);
		// Trim whitespace
		while (!baseType.empty() && baseType.back() == ' ') {
			baseType.pop_back();
		}
		return CppTypeToD(baseType) + "*";
	}
	
	// Handle template types like TArray<T>
	if (CppType.find('<') != std::string::npos) {
		// For now, just return the type as-is, but could be improved
		return CppType;
	}
	
	// Default: return as-is (for UE classes and structs)
	return CppType;
}

std::string DGenerator::MakeMemberString(const std::string& Type, const std::string& Name, std::string&& Comment)
{
	// Convert C++ type to D type
	std::string DType = CppTypeToD(Type);
	
	//<tab><--45 chars--><-------50 chars----->
	//     Type          MemberName;           // Comment
	int NumSpacesToComment;

	if (DType.length() < 45)
	{
		NumSpacesToComment = 50;
	}
	else if ((DType.length() + Name.length()) > 95)
	{
		NumSpacesToComment = 1;
	}
	else
	{
		NumSpacesToComment = 50 - (DType.length() - 45);
	}

	return std::format("\t{:{}} {}; {:{}} // {}\n", DType, 45, Name, " ", NumSpacesToComment, std::move(Comment));
}

std::string DGenerator::MakeMemberStringWithoutName(const std::string& Type)
{
	std::string DType = CppTypeToD(Type);
	return '\t' + DType + ";\n";
}

std::string DGenerator::GenerateBytePadding(const int32 Offset, const int32 PadSize, std::string&& Reason)
{
	return MakeMemberString("ubyte", std::format("Pad_{:X}[0x{:X}]", Offset, PadSize), std::format("0x{:04X}(0x{:04X})({})", Offset, PadSize, std::move(Reason)));
}

std::string DGenerator::GenerateBitPadding(uint8 UnderlayingSizeBytes, const uint8 PrevBitPropertyEndBit, const int32 Offset, const int32 PadSize, std::string&& Reason)
{
	return MakeMemberString(GetDTypeFromSize(UnderlayingSizeBytes), std::format("BitPad_{:X}_{:X} : {:d}", Offset, PrevBitPropertyEndBit, PadSize), std::format("0x{:04X}(0x{:04X})({})", Offset, UnderlayingSizeBytes, std::move(Reason)));
}

void DGenerator::WriteFileHead(StreamType& File, PackageInfoHandle Package, EFileType Type, const std::string& CustomFileComment, const std::string& CustomIncludes)
{
	namespace DSettings = Settings::CppGenerator; // Reuse C++ settings for now

	// Write D module declaration
	if (Type == EFileType::SdkD)
		File << "module sdk;\n\n";
	else if (Package.IsValidHandle())
		File << std::format("module sdk.{};\n\n", Package.GetName()) << std::endl;
	else
		File << "module sdk.basic;\n\n";

	File << R"(/*
* SDK generated by Dumper-7 for D language
*
* https://github.com/Encryqed/Dumper-7
*/

)";

	if (Type == EFileType::SdkD)
		File << std::format("// {}\n// {}\n", Settings::Generator::GameName, Settings::Generator::GameVersion);
	

	File << std::format("// {}\n\n", Package.IsValidHandle() ? std::format("Package: {}", Package.GetName()) : CustomFileComment);

	if (!CustomIncludes.empty())
		File << CustomIncludes + "\n";
}

void DGenerator::WriteFileEnd(StreamType& File, EFileType Type)
{
	// D files don't need explicit end markers like C++
	File << "\n";
}

void DGenerator::Generate()
{
	// Generate SDK.d with sorted packages
	StreamType SdkD(MainFolder / "SDK.d");
	GenerateSDKHeader(SdkD);

	// Generate PropertyFixup.d
	StreamType PropertyFixup(MainFolder / "PropertyFixup.d");
	GeneratePropertyFixupFile(PropertyFixup);

	// Generate UnrealContainers.d
	StreamType UnrealContainers(MainFolder / "UnrealContainers.d");
	GenerateUnrealContainers(UnrealContainers);

	StreamType DebugAssertions;

	if constexpr (Settings::Debug::bGenerateAssertionFile)
	{
		DebugAssertions.open(MainFolder / "DebugAssertions.d");
		GenerateDebugAssertions(DebugAssertions);
	}

	// Generate Basic.d  
	StreamType BasicD(MainFolder / "Basic.d");
	GenerateBasicFiles(BasicD, DebugAssertions);

	// TODO: Generate packages like the C++ generator does
	// For now, create a basic structure
}

void DGenerator::GenerateSDKHeader(StreamType& SdkD)
{
	WriteFileHead(SdkD, nullptr, EFileType::SdkD, "Includes the entire SDK. Import files directly for faster compilation!");

	// Import all the generated modules
	SdkD << "public import sdk.basic;\n";
	SdkD << "public import sdk.unrealcontainers;\n";
	SdkD << "public import sdk.propertyfixup;\n";

	auto ForEachElementCallback = [&SdkD](const PackageManagerIterationParams& OldParams, const PackageManagerIterationParams& NewParams, bool bIsStruct) -> void
	{
		PackageInfoHandle CurrentPackage = PackageManager::GetInfo(NewParams.RequiredPackage);

		const bool bHasClassesFile = CurrentPackage.HasClasses();
		const bool bHasStructsFile = (CurrentPackage.HasStructs() || CurrentPackage.HasEnums());

		if (bIsStruct && bHasStructsFile)
			SdkD << std::format("public import sdk.{}_structs;\n", CurrentPackage.GetName());

		if (!bIsStruct && bHasClassesFile)
			SdkD << std::format("public import sdk.{}_classes;\n", CurrentPackage.GetName());
	};

	PackageManager::IterateDependencies(ForEachElementCallback);

	WriteFileEnd(SdkD, EFileType::SdkD);
}

void DGenerator::GenerateBasicFiles(StreamType& BasicD, StreamType& AssertionsFile)
{
	WriteFileHead(BasicD, nullptr, EFileType::BasicD, "Basic D types and definitions");

	// Basic D equivalents of C++ types
	BasicD << R"(
// Basic types used throughout the SDK
alias int8 = byte;
alias int16 = short;
alias int32 = int;
alias int64 = long;
alias uint8 = ubyte;
alias uint16 = ushort;
alias uint32 = uint;
alias uint64 = ulong;

// Basic Unreal Engine types
struct FString
{
    // TODO: Implement FString for D
    void* Data;
}

struct FName  
{
    // TODO: Implement FName for D
    uint Index;
}

struct FText
{
    // TODO: Implement FText for D  
    void* Data;
}

)";

	WriteFileEnd(BasicD, EFileType::BasicD);
}

void DGenerator::GenerateUnrealContainers(StreamType& UEContainersHeader)
{
	WriteFileHead(UEContainersHeader, nullptr, EFileType::UnrealContainers, "Unreal Engine container types for D");

	UEContainersHeader << R"(
// Basic TArray implementation for D
struct TArray(T)
{
    T* Data;
    int Count;
    int Max;
    
    // TODO: Add TArray methods
}

// TODO: Add other container types like TSet, TMap, etc.

)";

	WriteFileEnd(UEContainersHeader, EFileType::UnrealContainers);
}

void DGenerator::GeneratePropertyFixupFile(StreamType& PropertyFixup)
{
	WriteFileHead(PropertyFixup, nullptr, EFileType::PropertyFixup, "Property fixup definitions");

	PropertyFixup << R"(
// Property fixup code for D
// TODO: Implement property fixup logic

)";

	WriteFileEnd(PropertyFixup, EFileType::PropertyFixup);
}

void DGenerator::GenerateDebugAssertions(StreamType& AssertionStream)
{
	WriteFileHead(AssertionStream, nullptr, EFileType::DebugAssertions, "Debug assertions");

	AssertionStream << R"(
// Debug assertion code for D
// TODO: Implement debug assertions

)";

	WriteFileEnd(AssertionStream, EFileType::DebugAssertions);
}

// Stub implementations for required methods
std::string DGenerator::GenerateMembers(const StructWrapper& Struct, const MemberManager& Members, int32 SuperSize, int32 SuperLastMemberEnd, int32 SuperAlign, int32 PackageIndex)
{
	// TODO: Implement member generation for D
	return "";
}

DGenerator::FunctionInfo DGenerator::GenerateFunctionInfo(const FunctionWrapper& Func)
{
	// TODO: Implement function info generation for D
	return FunctionInfo{};
}

std::string DGenerator::GenerateSingleFunction(const FunctionWrapper& Func, const std::string& StructName, StreamType& FunctionFile, StreamType& ParamFile, StreamType& AssertionFile)
{
	// TODO: Implement single function generation for D
	return "";
}

std::string DGenerator::GenerateFunctions(const StructWrapper& Struct, const MemberManager& Members, const std::string& StructName, StreamType& FunctionFile, StreamType& ParamFile, StreamType& AssertionFile)
{
	// TODO: Implement functions generation for D
	return "";
}

void DGenerator::GenerateStruct(const StructWrapper& Struct, StreamType& StructFile, StreamType& FunctionFile, StreamType& ParamFile, StreamType& AssertionFile, int32 PackageIndex, const std::string& StructNameOverride)
{
	// TODO: Implement struct generation for D
}

void DGenerator::GenerateEnum(const EnumWrapper& Enum, StreamType& StructFile)
{
	// TODO: Implement enum generation for D
}

std::string DGenerator::GetMemberTypeString(const PropertyWrapper& MemberWrapper, int32 PackageIndex, bool bAllowForConstPtrMembers)
{
	// TODO: Implement member type string generation for D
	return "";
}

std::string DGenerator::GetMemberTypeString(UEProperty Member, int32 PackageIndex, bool bAllowForConstPtrMembers)
{
	// TODO: Implement member type string generation for D
	return "";
}

std::string DGenerator::GetMemberTypeStringWithoutConst(UEProperty Member, int32 PackageIndex, bool* bOutIsUnknownProperty)
{
	// TODO: Implement member type string generation for D
	return "";
}

std::string DGenerator::GetFunctionSignature(UEFunction Func)
{
	// TODO: Implement function signature generation for D
	return "";
}

std::string DGenerator::GetStructPrefixedName(const StructWrapper& Struct)
{
	// TODO: Implement struct prefixed name for D
	return "";
}

std::string DGenerator::GetEnumPrefixedName(const EnumWrapper& Enum)
{
	// TODO: Implement enum prefixed name for D
	return "";
}

std::string DGenerator::GetEnumUnderlayingType(const EnumWrapper& Enm)
{
	// TODO: Implement enum underlying type for D
	return "";
}

std::string DGenerator::GetAssertionMacroString(const std::string& PrefixedStructUniqueName)
{
	// TODO: Implement assertion macro string for D
	return "";
}

std::string DGenerator::GetCycleFixupType(const StructWrapper& Struct, bool bIsForInheritance)
{
	// TODO: Implement cycle fixup type for D
	return "";
}

std::unordered_map<std::string, UEProperty> DGenerator::GetUnknownProperties()
{
	// TODO: Implement unknown properties for D
	return {};
}

void DGenerator::GenerateEnumFwdDeclarations(StreamType& ClassOrStructFile, PackageInfoHandle Package, bool bIsClassFile)
{
	// TODO: Implement enum forward declarations for D
}

void DGenerator::InitPredefinedMembers()
{
	// TODO: Initialize predefined members for D
}

void DGenerator::InitPredefinedFunctions()
{
	// TODO: Initialize predefined functions for D
}